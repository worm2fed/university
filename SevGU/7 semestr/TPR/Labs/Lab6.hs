import           Control.Applicative (ZipList (..))

type Row a = [a]
type Matrix a = [Row a]


inputA1 :: Matrix Double
inputA1 =
  [ [ 1.0, 1.0, 2.0, 0.5  ] -- фундаментальные знания, которые содержит предмет
  , [ 1.0, 1.0, 2.0, 0.5  ] -- соответствие современному уровню развития науки в данной области
  , [ 0.5, 0.5, 1.0, 0.25 ] -- возможность использования в профессиональной деятельности
  , [ 2.0, 2.0, 4.0, 1.0  ] -- симпатии к преподавателю
  ]

inputA21 :: Matrix Double -- фундаментальные знания, которые содержит предмет
inputA21 =
  [ [ 1.0,  6.0, 4.0,  4.0,  2.0,  3.0  ] -- теория принятия решений
  , [ 0.17, 1.0, 0.67, 0.67, 0.34, 0.5  ] -- теория алгоритмов
  , [ 0.25, 1.5, 1.0,  1.0,  0.5,  0.75 ] -- теория вероятностей и математическая статистика
  , [ 0.25, 1.5, 1.0,  1.0,  0.5,  0.75 ] -- теория информационных процессов
  , [ 0.5,  3.0, 2.0,  2.0,  1.0,  1.5  ] -- технологии обработки информации
  , [ 0.34, 2.0, 1.34, 1.34, 0.67, 1.0  ] -- технологии программирования
  ]

inputA22 :: Matrix Double -- соответствие современному уровню развития науки в данной области
inputA22 =
  [ [ 1.0,  2.0,  1.0,  1.0,  2.0,  3.0  ] -- теория принятия решений
  , [ 0.5,  1.0,  0.5,  0.5,  1.0,  1.5  ] -- теория алгоритмов
  , [ 1.0,  2.0,  1.0,  1.0,  2.0,  3.0  ] -- теория вероятностей и математическая статистика
  , [ 1.0,  2.0,  1.0,  1.0,  2.0,  3.0  ] -- теория информационных процессов
  , [ 0.5,  1.0,  0.5,  0.5,  1.0,  1.5  ] -- технологии обработки информации
  , [ 0.34, 0.67, 0.34, 0.34, 0.67, 1.0  ] -- технологии программирования
  ]

inputA23 :: Matrix Double -- возможность использования в профессиональной деятельности
inputA23 =
  [ [ 1.0, 2.0, 1.0, 2.0, 2.0, 2.0 ] -- теория принятия решений
  , [ 0.5, 1.0, 0.5, 1.0, 1.0, 1.0 ] -- теория алгоритмов
  , [ 1.0, 2.0, 1.0, 2.0, 2.0, 2.0 ] -- теория вероятностей и математическая статистика
  , [ 0.5, 1.0, 0.5, 1.0, 1.0, 1.0 ] -- теория информационных процессов
  , [ 0.5, 1.0, 0.5, 1.0, 1.0, 1.0 ] -- технологии обработки информации
  , [ 0.5, 1.0, 0.5, 1.0, 1.0, 1.0 ] -- технологии программирования
  ]

inputA24 :: Matrix Double -- симпатии к преподавателю
inputA24 =
  [ [ 1.0,  3.0, 1.0,  1.0,  1.0,  3.0 ] -- теория принятия решений
  , [ 0.34, 1.0, 0.34, 0.34, 0.34, 1.0 ] -- теория алгоритмов
  , [ 1.0,  3.0, 1.0,  1.0,  1.0,  3.0 ] -- теория вероятностей и математическая статистика
  , [ 1.0,  3.0, 1.0,  1.0,  1.0,  3.0 ] -- теория информационных процессов
  , [ 1.0,  3.0, 1.0,  1.0,  1.0,  3.0 ] -- технологии обработки информации
  , [ 0.34, 1.0, 0.34, 0.34, 0.34, 1.0 ] -- технологии программирования
  ]

calcW :: Matrix Double -> Maybe (Row Double)
calcW matrix = if sum normalized == 1.0 then Just normalized else Nothing
  where
    summed = foldr ((:) . sum) [] matrix
    normalized = map (/ sum summed) summed

multRow :: Num a => Row a -> Matrix a -> Row a
multRow v = map (sum . zipWith (*) v)

calcLambda :: Matrix Double -> Maybe (Double, Double)
calcLambda matrix = do
  let n = fromIntegral (length matrix)
  w <- calcW matrix
  let w' = multRow w matrix
  let w'' = zipWith (/) w' w
  let lambda = sum w'' / n
  return (lambda, (lambda - n) / (n - 1))

transpose :: Matrix a -> Matrix a
transpose = getZipList . traverse ZipList

getW2O :: [Matrix Double] -> Maybe (Matrix Double)
getW2O a2 = transpose <$> traverse calcW a2

calcD :: Matrix Double -> [Matrix Double] -> Maybe (Row Double)
calcD a1 a2 = do
  w <- calcW a1
  w2o <- getW2O a2
  return $ multRow w w2o

findSolution :: Matrix Double -> [Matrix Double] -> Maybe (Double, Int)
findSolution a1 a2 = maximum <$> (zip <$> calcD a1 a2 <*> Just [1..])
